// Generated by CoffeeScript 1.9.2
(function() {
  var Quadrigacx, crypto, qs, request;

  request = require('request');

  crypto = require('crypto');

  qs = require('querystring');

  module.exports = Quadrigacx = (function() {
    function Quadrigacx(client_id, key, secret) {
      this.url = 'https://api.quadrigacx.com';
      this.version = 'v2';
      this.client_id = client_id;
      this.key = key;
      this.secret_hash = crypto.createHash('md5').update(secret).digest('hex');
      this.nonce = Math.ceil((new Date()).getTime() / 1000);
    }

    Quadrigacx.prototype._nonce = function() {
      return ++this.nonce;
    };

    Quadrigacx.prototype.public_request = function(path, params, cb) {
      var err, options;
      options = {
        url: this.url + '/' + this.version + '/' + path,
        method: 'GET',
        timeout: 15000,
        json: true
      };
      if (typeof params === 'function') {
        cb = params;
      } else {
        try {
          options['url'] += '/?' + qs.stringify(params);
        } catch (_error) {
          err = _error;
          return cb(err);
        }
      }
      try {
        return request(options, function(err, response, body) {
          if (err || (response.statusCode !== 200 && response.statusCode !== 400)) {
            return cb(new Error(err != null ? err : response.statusCode));
          }
          return cb(null, body);
        });
      } catch (_error) {
        err = _error;
        console.log("CATCHING ERROR IN Quadrigacx PUBLIC");
        return cb(err);
      }
    };

    Quadrigacx.prototype.private_request = function(path, params, cb) {
      var err, key, nonce, options, payload, signature, signature_string, value;
      if (typeof params === 'function') {
        cb = params;
        params = {};
      }
      try {
        nonce = this._nonce();
        signature_string = nonce + this.client_id + this.key;
        signature = crypto.createHmac("sha256", this.secret_hash).update(signature_string).digest('hex');
        payload = {
          key: this.key,
          nonce: nonce,
          signature: signature
        };
        for (key in params) {
          value = params[key];
          payload[key] = value;
        }
        options = {
          url: this.url + '/' + this.version + '/' + path,
          method: "POST",
          body: payload,
          timeout: 15000,
          json: true
        };
        try {
          return request(options, function(err, response, body) {
            if (err || (response.statusCode !== 200 && response.statusCode !== 400)) {
              return cb(new Error(err != null ? err : response.statusCode));
            }
            return cb(null, body);
          });
        } catch (_error) {
          err = _error;
          console.log("CATCHING ERROR IN Quadrigacx PRIVATE");
          return cb(err);
        }
      } catch (_error) {
        err = _error;
        return cb(err);
      }
    };

    Quadrigacx.prototype.api = function(method, params, cb) {
      var methods;
      methods = {
        "public": ['ticker', 'order_book', 'transactions'],
        "private": ['balance', 'user_transactions', 'open_orders', 'lookup_order', 'cancel_order', 'buy', 'sell', 'bitcoin_deposit_address', 'bitcoin_withdrawal']
      };
      if (methods['public'].indexOf(method) !== -1) {
        return this.public_request(method, params, cb);
      }
      if (methods['private'].indexOf(method) !== -1) {
        return this.private_request(method, params, cb);
      }
      return cb(new Error('no such method: ' + method));
    };

    return Quadrigacx;

  })();

}).call(this);
